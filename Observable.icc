#include <iostream>
#include <vector>
#include <cmath>
#include "Random.h"
#include "Pdf.h"
#include "Range.h"


namespace OBS {

  Base::Base():m_pdf(0),m_mean(0),m_sigma(0),m_dist(PDF::DIST_UNDEF),
               m_locked(false),m_valid(false),m_rndGen(0),
               m_obsVal(0),m_intScale(1.0),m_intNpts(1),m_intTotal(0),
               m_intFilled(false) {
  }

  Base::Base(const char *name, const char *description):
    m_pdf(0),m_mean(0),m_sigma(0),m_dist(PDF::DIST_UNDEF),
    m_locked(false),m_valid(false),m_rndGen(0),
    m_obsVal(0),m_intScale(1.0),m_intNpts(1),m_intTotal(0),
    m_intFilled(false) {
    if (name) m_name=name;
    if (description) m_description=description;
  }

  Base::Base(const Base & other) { copy(other);}
  //
  Base::~Base() {}
  //
  void Base::setObservedValue( double v ) {
    if (this->isDouble())   static_cast<BaseType<double> *>(this)->setObservedValue(v);
    else if (this->isInt()) static_cast<BaseType<int> *>(this)->setObservedValue(static_cast<int>(v));
    else {
      std::cout << "FATAL: OBS::Base::setObservedValue(double): not supported type!" << std::endl;
      exit(-1);
    }
  }
  void Base::setObservedValue( int v ) {
    if (this->isInt())         static_cast<BaseType<int> *>(this)->setObservedValue(v);
    else if (this->isDouble()) static_cast<BaseType<double> *>(this)->setObservedValue(static_cast<int>(v));
    else {
      std::cout << "FATAL: OBS::Base::setObservedValue(int): not supported type!" << std::endl;
      exit(-1);
    }
  }
  void Base::getObservedValue( int & v ) const {
    if (this->isInt())         static_cast<const BaseType<int> *>(this)->getObservedValue(v);
    else if (this->isDouble()) v = static_cast<const int>(m_obsVal);
    else {
      std::cout << "FATAL: OBS::Base::getObservedValue(int): not supported type!" << std::endl;
      exit(-1);
    }
  }

  void   Base::getObservedValue( double & v ) const { v = m_obsVal; }

  double Base::getObservedValue() const { return m_obsVal;}

  // setting name, pdf and rdn generator
  void         Base::setName(const char *name)               { m_name=name;}
  void         Base::setDescription(const char *description) { m_description=description;}
  void         Base::lock()                                  { m_locked = true; }
  void         Base::unlock()                                { m_locked = false; }
  void         Base::setPdf(PDF::Base *pdf)                  { m_pdf = pdf; m_dist = ((pdf==0) ? PDF::DIST_NONE:pdf->getDist());}
  void         Base::setPdfDist(const PDF::DISTYPE dist)     { if (m_pdf==0) m_dist = dist; }
  void Base::setPdfMean(double m)                    { m_mean = m; }
  void Base::setPdfSigma(double m)                   { m_sigma = m; } //if (m_pdf) m_pdf->setSigma(m); }
  void         Base::setRndGen(RND::Random *rndgen)          { m_rndGen = rndgen;}
  void Base::validate()                              { m_valid = ((m_pdf!=0) && (m_rndGen!=0)); }

  double Base::aprioriProb( double x ) { return 1.0;}

  // setting integral related
  void Base::setIntNpts(int n)     { m_intNpts = n; }
  void Base::setIntScale(double s) { m_intScale = s; }
  void Base::setIntXRange(double xmin, double xmax, double step, int n) {
    m_intFilled = false;
    m_intXRange.setRange(xmin,xmax,step,n);
  }

  double Base::transIntX(double x) { return x; }

  void Base::calcIntRange(double & low, double & high, double mean, double sigma, bool positive)
  {
    double dx;
    const double maxp = 0.9999;
    int n=0, nprev, nlow, nhigh;
    double p=0.0;
    //  PDF::DISTYPE dist = pdf->getDist();
    //
    if (m_dist==PDF::DIST_NONE) {
      low  = mean;
      high = mean;
    } else {
      switch (m_dist) {
      case PDF::DIST_GAUS2D:
      case PDF::DIST_GAUS:
      case PDF::DIST_LOGN:
        low  = mean - m_intScale*sigma;
        high = mean + m_intScale*sigma;
        break;
      case PDF::DIST_FLAT:
        dx=sigma*1.73205081; // == sqrt(12)*0.5; ignore scale - always use full range
        low  = mean-dx;
        high = mean+dx;
        break;
      case PDF::DIST_POIS:
        nlow  = -1;
        nhigh = -1;
        // find min and max range of poisson
        // this is defined by maxp above
        // low  : max N for wich sum( p(n) ) < 1.0-maxp
        // high : min N for wich sum( p(n) ) > maxp
        while (nhigh<0) {
          nprev=n;
          p += PDF::gPoisTab.getVal( n, mean );
          //          p += pdf->getVal( n, mean );
          //p += m_pdf->getVal( n, mean );
          if ((n==0) || (p<(1.0-maxp))) nlow  = n;
          if (p>maxp)       nhigh = n;
          n++;
          if (nprev>n) { // just a STUPID test; can be done better...
            std::cerr << "Infinite loop caugh in OBS::calcIntRange() for Poisson - brutal exit" << std::endl;
            exit(-1);
          }
        }
        //
        m_intNpts = nhigh-nlow+1;
        //
        low  = static_cast<double>(nlow);
        high = static_cast<double>(nhigh);
        break;
      default: // ERROR STATE
        low  = 0;
        high = 0;
        std::cerr << "OBS::calcIntRange() -> Unknown pdf type = " << m_dist << std::endl;
        break;
      }
    }
    if (positive && (low<0)) {
      high = high-low;
      low = 0;
    }
  }
  
  void Base::initInt() {
    if (m_intXRange.n()<1) return;
    int np = m_intXRange.n();
    m_intWeight.resize(np,0.0);
    m_intX.resize(np,0.0);
    //
    double x;
    for (int i=0; i<np; i++) {
      x = m_intXRange.getVal(i);
      x = transIntX(x);
      m_intX[i] = x; //! for LOGN, the Xrange is in log(x)
    }

    m_intTotal = 0;
    m_intFilled = false;
  }

  void Base::initInt(double xmin, double xmax, double step, int n) {
    this->setIntXRange(xmin,xmax,step,n);
    this->initInt();
  }

  //! init with zero range
  void Base::initIntConst() {
    this->initInt(m_obsVal,m_obsVal,0,1);
  }

  //! init with default range, given by observed value, sigma and scale
  void Base::initIntegral() {
    if (this->constant()) { // takes care of DIST_NONE, DIST_UNDEF
      this->initIntConst();
    } else {
      double low;
      double high;
      bool pos=true;
      double mean, sigma;
      switch ( this->m_dist ) {
      case PDF::DIST_LOGN:
        mean = PDF::calcLogMean(m_obsVal,double(m_sigma));
        sigma = PDF::calcLogSigma(m_obsVal,double(m_sigma));
        pos = false;
        break;
      case PDF::DIST_POIS:
        mean = m_obsVal;
        sigma = sqrt((mean>0 ? mean:0.0));
        pos = true;
        break;
      default:
        mean = m_obsVal;
        sigma = m_sigma;
        pos = true;
      }
      this->calcIntRange(low,high, mean , sigma, pos);
      this->initInt(low,high,0,m_intNpts);
    }
  }

  void Base::fillInt() {
    if (m_intFilled) return;
    int np = int(m_intX.size());
    double f;
    //      double dx = static_cast<double>(m_intXRange.step());
    double dx;
    m_intTotal=0;
    if (np<1) return;
    if (np==1) { // Dirac spike - integral and weight == 1.0
      m_intWeight[0] = 1.0;
      m_intTotal = 1.0;
    } else {
      for (int i=0; i<np-1; i++) {
        f = this->getPdfVal(m_intX[i])*this->aprioriProb(m_intX[i]);
        dx = static_cast<double>(m_intX[i+1]-m_intX[i]); // might be lognormal!
        m_intWeight[i] = f*dx;
        m_intTotal += m_intWeight[i];
      }
    }
    m_intFilled = true;
  }

  // print out
  void Base::dump() const {
    //      std::cout << "OBS::Base::dump(): observable dump not yet implemented" << std::endl;
    std::cout << "--------------------------------------------" << std::endl;
    std::cout << "OBS::Base:dump()" << std::endl;
    std::cout << "Name : " << this->getName() << std::endl;
    std::cout << "Mean : " << this->getPdfMean() << std::endl;
    std::cout << "Sigma: " << this->getPdfSigma() << std::endl;
    std::cout << "Dist : " << PDF::distTypeStr(this->getPdfDist()) << std::endl;
    std::cout << "Obs  : " << this->getObsVal() << std::endl;
    std::cout << "--------------------------------------------" << std::endl;
  }

  const double Base::getPdfVal(double val) {
    return (this->m_pdf ? (this->m_pdf)->getVal(val,this->m_mean,this->m_sigma):0.0);
  }
  // accessors
  const std::string & Base::getName()        const { return this->m_name;}
  const std::string & Base::getDescription() const { return this->m_description;}
  const double        Base::getPdfMean()     const { return this->m_mean; } //(m_pdf ? m_pdf->getMean():0); }
  const double        Base::getPdfSigma()    const { return this->m_sigma; } //(m_pdf ? m_pdf->getSigma():0); }
  const PDF::DISTYPE  Base::getPdfDist()     const { return this->m_dist; }
  PDF::Base          *Base::getPdf()         const { return this->m_pdf;}
  RND::Random        *Base::getRndGen()      const { return this->m_rndGen;}
    
  // status
  const bool Base::constant() const { return (m_locked || (m_dist==PDF::DIST_NONE) || (m_dist==PDF::DIST_UNDEF)); }
  const bool Base::locked()   const { return m_locked;}
  const bool Base::valid()    const { return m_valid;}

  // integral accessors
  const bool                 Base::isIntFilled()       const { return m_intFilled; }
  const double               Base::getIntScale()       const { return m_intScale; }
  const std::vector<double> *Base::getIntWeight()      const { return &m_intWeight; }
  const double               Base::getIntWeight(int i) const { return m_intWeight[i]; }
  const double               Base::getIntegral()       const { return m_intTotal; }
  const Range<double>       *Base::getIntXRange()      const { return &m_intXRange; } //! Integration range - log(x) if DIST_LOGN
  const double               Base::getIntdX()          const { return m_intXRange.step(); }
  const std::vector<double> *Base::getIntX()           const { return &m_intX; } //! Always x (even for LOGN)
  const double               Base::getIntX(int i)      const { return m_intX[i]; }
  const double               Base::getIntXmin()        const { return m_intX.front(); }
  const double               Base::getIntXmax()        const { return m_intX.back(); }
  const int                  Base::getIntN()           const { return static_cast<int>(m_intX.size()); }

  bool Base::isInt()    const { return false; }
  bool Base::isDouble() const { return false; }
  bool Base::isFloat()  const { return false; }

  // protected methods
  const double  Base::getObsVal() const { return m_obsVal; } // users should not use this one - only set in BaseType<T>
  void Base::copy(const Base & other) {
    if (this != &other) {
      m_pdf    = other.getPdf();
      m_mean   = other.getPdfMean();
      m_sigma  = other.getPdfSigma();
      m_dist   = other.getPdfDist();
      m_obsVal = other.getObsVal();
      m_rndGen = other.getRndGen();
      m_valid  = other.valid();
      m_locked = other.locked();
      m_name   = "Copy of " + other.getName();
      m_description = other.getDescription();
      // integral stuff
      m_intFilled     = other.isIntFilled();
      m_intWeight     = *(other.getIntWeight());
      m_intXRange     = *(other.getIntXRange());
      m_intX          = *(other.getIntX());
      m_intTotal      = other.getIntegral();
      m_intScale      = other.getIntScale();
      m_intNpts       = other.getIntN();
    }
  }

  //////////////////////////////////


  template <typename T>
  BaseType<T>::BaseType():Base() {}
  template <typename T>
  BaseType<T>::BaseType(const char *name,const char *desc):Base(name,desc) {}
  template <typename T>
  BaseType<T>::BaseType(PDF::BaseType<T> *pdf, RND::Random *rndgen, const char *name, const char *description):
    Base(name,description) {
    this->m_rndGen = rndgen;
    this->m_valid=((pdf!=0)&&(rndgen!=0));
    this->setPdf(pdf);
    this->setObsVal(0);
    if (pdf) this->setObsVal(static_cast<T>(this->m_mean));
    m_intFilled = false;
    m_intScale = 5.0;
    m_intNpts  = 20;
  }

  template <typename T>
  BaseType<T>::BaseType(const BaseType<T> & other):Base() { this->copy(other);}
  template <typename T>
  BaseType<T>::~BaseType() {}
    //
  template <typename T>
  T BaseType<T>::rnd() { return m_observedValue; }
  //
  template <typename T>
  BaseType<T> const & BaseType<T>::operator=(BaseType<T> const & rh) {
    this->copy(rh);
    return *this;
  }

  template <typename T>
  BaseType<T> *BaseType<T>::clone() const {
    BaseType<T> *obj = new BaseType<T>(*this);
    return obj;
  }

  template <typename T>
  const double BaseType<T>::getPdfVal(T val) {
    return (this->m_pdf ? static_cast< PDF::BaseType<T> * >(this->m_pdf)->getVal(val,this->m_mean,this->m_sigma):0.0);
  }

  template <typename T>
  T       BaseType<T>::operator()()       { return ( this->m_locked ? m_observedValue:rnd()); }
  template <typename T>
  double  BaseType<T>::operator()(T val)  { return this->getPdfVal(val); }
  //
  template <typename T>
  void BaseType<T>::setObservedRnd()          { if (!this->m_locked) this->setObsVal(rnd());}
  template <typename T>
  void BaseType<T>::setObservedValue(T val)   { this->setObsVal(val); }
  template <typename T>
  void BaseType<T>::setObservedValue()        { this->setObsVal(static_cast<T>(this->getPdfMean())); }
  //
  template <typename T>
  const double BaseType<T>::getObservedValue()        const { return m_obsVal; }
  template <typename T>
  const void   BaseType<T>::getObservedValue(T & val) const { val = m_observedValue; }

  template <typename T>
  void BaseType<T>::dump() const {
    //      std::cout << "OBS::Base::dump(): observable dump not yet implemented" << std::endl;
    std::cout << "--------------------------------------------" << std::endl;
    std::cout << "OBS::BaseType<T>:dump()" << std::endl;
    std::cout << "Name : " << this->getName() << std::endl;
    std::cout << "Mean : " << this->getPdfMean() << std::endl;
    std::cout << "Sigma: " << this->getPdfSigma() << std::endl;
    std::cout << "Dist : " << PDF::distTypeStr(this->getPdfDist()) << std::endl;
    std::cout << "Obs  : " << this->getObservedValue() << std::endl;
    std::cout << "--------------------------------------------" << std::endl;
  }
  
  template <typename T>
  bool BaseType<T>::isInt()    const { return false; }
  template <typename T>
  bool BaseType<T>::isDouble() const { return false; }
  template <typename T>
  bool BaseType<T>::isFloat()  const { return false; }
  
  //
  template <typename T>
  void BaseType<T>::setObsVal( T val) {
    m_obsVal = static_cast<double>(val);
    m_observedValue = val;
  }
  template <typename T>
  void BaseType<T>::copy(const BaseType<T> & other) {
    if (this != &other) {
      Base::copy(other);
      other.getObservedValue(m_observedValue);
    }
  }

  template<> inline bool BaseType<int>::isInt()         const { return true; }
  template<> inline bool BaseType<double>::isDouble()   const { return true; }
  template<> inline bool BaseType<float>::isFloat()     const { return true; }


  ObservableGauss::ObservableGauss():BaseType<double>("gauss","Gaussian observable") {
    this->m_dist=PDF::DIST_GAUS;
  };

  ObservableGauss::ObservableGauss(PDF::Gauss *pdf, RND::Random *rndGen, const char *name, const char *desc):
    BaseType<double>(pdf,rndGen,name,desc) {};

  ObservableGauss::ObservableGauss(const ObservableGauss & other) {
    BaseType<double>::copy(other);
  }
  ObservableGauss::~ObservableGauss() {};
  //
  ObservableGauss const & ObservableGauss::operator=(ObservableGauss const & rh) {
    BaseType<double>::copy(rh);
    return *this;
  }
  //
  double ObservableGauss::rnd() {
    return (this->m_valid ? this->m_rndGen->gauss(this->m_mean,this->m_sigma):0);
  }

  ObservableGauss *ObservableGauss::clone() const {
    ObservableGauss *obj = new ObservableGauss(*this);
    return obj;
  }

  ////////////////////////////////////////////////////////////

  ObservableLogN::ObservableLogN():BaseType<double>("gauss","Gaussian observable") {
    m_dist=PDF::DIST_LOGN;
  };
    
  ObservableLogN::ObservableLogN(PDF::LogNormal *pdf, RND::Random *rndGen, const char *name, const char *desc):
    BaseType<double>(pdf,rndGen,name,desc) {};

  ObservableLogN::ObservableLogN(const ObservableLogN & other) {
    BaseType<double>::copy(other);
  }
  ObservableLogN::~ObservableLogN() {};
  //
  ObservableLogN const & ObservableLogN::operator=(ObservableLogN const & rh) {
    ObservableLogN::copy(rh);
    return *this;
  }
  //
  double ObservableLogN::rnd() {
    PDF::LogNormal *pdf = static_cast<PDF::LogNormal *>(m_pdf);
    return (m_valid ? m_rndGen->logNormalLN(pdf->getLogMean(),pdf->getLogSigma()):0);
  }

  ObservableLogN *ObservableLogN::clone() const {
    ObservableLogN *obj = new ObservableLogN(*this);
    return obj;
  }

  double ObservableLogN::transIntX(double x) {
    return exp(x);
  }
  //////////////////////////////////////////////////////////////////
  
  ObservablePois::ObservablePois():BaseType<int>("poisson","Poisson observable") {
    this->m_dist=PDF::DIST_POIS;
    m_excludeZero=false;
  }

  ObservablePois::ObservablePois(PDF::Poisson *pdf, RND::Random *rndGen, const char *name, const char *desc):
    BaseType<int>(pdf,rndGen,name,desc) {
    m_excludeZero=false;
  }

  ObservablePois::ObservablePois(PDF::PoisTab *pdf, RND::Random *rndGen, const char *name, const char *desc):
    BaseType<int>(pdf,rndGen,name,desc) {
    m_excludeZero=false;
  }

  ObservablePois::ObservablePois(const ObservablePois & other) {
    BaseType<int>::copy(other);
    m_excludeZero = other.getExcludeZeroFlag();
  }
  ObservablePois::~ObservablePois() {};

  ObservablePois const & ObservablePois::operator=(ObservablePois const & rh) {
    BaseType<int>::copy(rh);
    m_excludeZero = rh.getExcludeZeroFlag();
    return *this;
  }
  //
  void ObservablePois::setExcludeZero() {
    m_excludeZero = true;
  }
  void ObservablePois::setIncludeZero() {
    m_excludeZero = false;
  }
  bool ObservablePois::getExcludeZeroFlag() const {
    return m_excludeZero;
  }

  double ObservablePois::aprioriProb( double x ) { // currently a simple implementation for poisson
    double rval = 1.0;
    if ((m_dist==PDF::DIST_POIS) && (m_excludeZero)) {
      if (x<0.5) rval = 0.0;
    }
    return rval;
  }
  void ObservablePois::setPdfMean(double m)  {
    this->m_mean = m;
    this->m_sigma = (m>0 ? sqrt(m):0.0);
  }
  void ObservablePois::setPdfSigma(double m) {
    this->m_mean  = m*m;
    this->m_sigma = m;
  }
  int ObservablePois::rnd() {
    return (this->m_valid ? this->m_rndGen->poisson(this->m_mean):0);
  }

  ObservablePois *ObservablePois::clone() const {
    ObservablePois *obj = new ObservablePois(*this);
    return obj;
  }

  ///////////////////////////////////////////////////////////

  ObservableFlat::ObservableFlat():BaseType<double>("flat","Flat observable") {
    m_dist=PDF::DIST_FLAT;
  }
  ObservableFlat::ObservableFlat(PDF::Flat *pdf, RND::Random *rndGen, const char *name, const char *desc):
    BaseType<double>(pdf,rndGen,name,desc) {};

  ObservableFlat::ObservableFlat(const ObservableFlat & other) {
    BaseType<double>::copy(other);
  }
  ObservableFlat::~ObservableFlat() {};
  //
  ObservableFlat const & ObservableFlat::operator=(ObservableFlat const & rh) {
    BaseType<double>::copy(rh);
    return *this;
  }
  //
  double ObservableFlat::rnd() {
    return (m_valid ? m_rndGen->flat(m_mean,m_sigma):0);
  }

  ObservableFlat *ObservableFlat::clone() const {
    ObservableFlat *obj = new ObservableFlat(*this);
    return obj;
  }
  //////////////////////////////////////////////////
  Correlated::Correlated() {}
  Correlated::~Correlated() {}
  //
  bool  Correlated::add(Base *obs) { return false;}
  Base *Correlated::find(const char *name) {return 0;}
  bool  Correlated::setCorrelation(const char *v1, const char *v2, double c) {return false;}
  bool  Correlated::setCorrelation(const Base *v1, const Base *v2, double c) {return false;}
    //
  void  Correlated::rnd() {} // generate random observation

  //////////////////////////////////////////////////

  Base *makeObservable(PDF::DISTYPE dist) {
    Base *obs=0;
    switch (dist) {
    case PDF::DIST_UNDEF:
    case PDF::DIST_NONE:
      obs=new BaseType<double>();
      obs->setPdf(0);
      break;
    case PDF::DIST_POIS:
      obs=new ObservablePois();
      obs->setPdf(&PDF::gPoisTab);
      break;
    case PDF::DIST_GAUS:
      obs=new ObservableGauss();
      obs->setPdf(&PDF::gGauss);
      break;
    case PDF::DIST_FLAT:
      obs=new ObservableFlat();
      obs->setPdf(&PDF::gFlat);
      break;
    case PDF::DIST_LOGN:
      obs=new ObservableLogN();
      obs->setPdf(&PDF::gLogNormal);
      break;
    default:
      std::cout << "FATAL: Unknown distribution = " << distTypeStr(dist) << std::endl;
      exit(-1);
      break;
    }
    if (obs) {
      obs->setRndGen(&RND::gRandom);
      obs->validate();
    }
    return obs;
  };

  /////////////////////
  Base *clone( const Base *bptr ) {
    if (bptr==0) return 0;
    if (bptr->isInt())    return dynamic_cast<const BaseType<int> *>(bptr)->clone();
    if (bptr->isDouble()) return dynamic_cast<const BaseType<double> *>(bptr)->clone();
    if (bptr->isFloat())  return dynamic_cast<const BaseType<float> *>(bptr)->clone();
    return 0;
  }

};


