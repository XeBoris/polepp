#ifdef TABULATOR_H

#ifndef TABULATOR_ICC
#define TABULATOR_ICC

template<class T>
Tabulator<T>::Tabulator(const char *name, const char *desc) : ITabulator(name,desc) {
}

template<class T>
Tabulator<T>::Tabulator() : ITabulator() {
}

template<class T>
Tabulator<T>::~Tabulator() {
}

template<class T>
void Tabulator<T>::setFunction(const T *fun) {
   m_function = fun;
}

template<class T>
void Tabulator<T>::setNTabPar( size_t npars ) {
   m_tabName.resize(npars);
   m_tabIndex.resize(npars);
   m_tabMin.resize(npars);
   m_tabMax.resize(npars);
   m_tabStep.resize(npars);
   m_tabNsteps.resize(npars);
   m_tabMaxInd.resize(npars);
   m_tabulated = false;
}

template<class T>
void Tabulator<T>::setTabPar( const char *name, int index, double xmin, double xmax, double step, size_t nsteps, int parInd ) {
   std::string nameStr = (name ? std::string(name) : std::string("<nn>") );
   if ((parInd<0) || (parInd-1>static_cast<int>(m_tabName.size()))) { // push_back values
      m_tabName.push_back( nameStr );
      m_tabIndex.push_back(index);
      m_tabMin.push_back(xmin);
      m_tabMax.push_back(xmax);
      m_tabStep.push_back(step);
      m_tabNsteps.push_back(nsteps);
      m_tabMaxInd.push_back(nsteps-1);
   } else {
      m_tabName[parInd]   = nameStr;
      m_tabIndex[parInd]  = index;
      m_tabMin[parInd]    = xmin;
      m_tabMax[parInd]    = xmax;
      m_tabStep[parInd]   = step;
      m_tabNsteps[parInd] = nsteps;
      m_tabMaxInd[parInd] = nsteps-1;
   }
   m_tabulated = false;
}

template<class T>
void Tabulator<T>::addTabParStep( const char *name, int index, double xmin, double xmax, double step, int parInd ) {
   if (xmax<=xmin) return; // FAIL!
   if (step<=0)  return;
   size_t nsteps = static_cast<size_t>(((xmax-xmin)/step)+1.5);
   setTabPar( name, index, xmin, xmax, step, nsteps, parInd );
}

template<class T>
void Tabulator<T>::addTabParNsteps( const char *name, int index, double xmin, double xmax, size_t nsteps, int parInd ) {
   if (xmax<=xmin)  return; // FAIL!
   if (nsteps<=0) return;
   double step = ( nsteps>1 ? (xmax-xmin)/(static_cast<double>(nsteps-1)) : 0.0 );
   setTabPar( name, index, xmin, xmax, step, nsteps, parInd );
}

template<class T>
void Tabulator<T>::clrTable() {
   m_tabulated = false;
   m_tabName.clear();
   m_tabIndex.clear();
   m_tabMin.clear();
   m_tabMax.clear();
   m_tabStep.clear();
   m_tabNsteps.clear();
   m_tabValues.clear();
   m_tabMaxInd.clear();
   m_parameters.clear();
   m_parChanged.clear();
}

template<class T>
void Tabulator<T>::initTable() {
   m_parameters.resize( m_tabMin.size() );
   m_parChanged.resize( m_tabMin.size(), true );
   m_parIndex.resize( m_tabMin.size() );
}

// This will tabulate using calcValue() and the given ranges.
template<class T>
void Tabulator<T>::tabulate() {
   initTable();
   std::vector<size_t> indvec(m_tabMin.size(),0);
   std::vector<size_t> indvecPrev;
   // generate all possible combinations of N(steps)
   do {
      setParameters( indvec, indvecPrev );
      m_tabValues.push_back( calcValue() );
      indvecPrev = indvec;
      //      std::cout << "POIS: " << m_tabValues.back() << std::endl;
   } while (Combination::next_vector(indvec,m_tabMaxInd));
   m_tabulated = true;
}

template<class T>
int Tabulator<T>::calcTabIndex( const std::vector<double> & valvec ) {
   bool fail=false;
   int rval=0;
   size_t ind;
   size_t indtab;
   size_t iprod=1;
   for (size_t i=valvec.size(); i>0; i--) {
      ind = i-1;
      //      std::cout << valvec[i] << " inside [ " << m_tabMin[i] << "," << m_tabMax[i] << "] ?" << std::endl;
      fail = ((valvec[ind]<m_tabMin[ind]) || (valvec[ind]>m_tabMax[ind]));
      //      if (fail) std::cout << "NO!" << std::endl;
      if (fail) break;
      //      std::cout << "YES!" << std::endl;
      //
      indtab = static_cast<int>(0.5+((valvec[ind] - m_tabMin[ind])/m_tabStep[ind]));
      m_parIndex[ind] = indtab;
      rval += indtab*iprod;
      iprod *= m_tabNsteps[ind];
   }
   if (fail) rval = -1;
   if (rval>=static_cast<int>(m_tabValues.size())) {
      std::cout << "SHIT!!!!" << std::endl;
   }
   //   std::cout << "VAL: " << valvec[0] << ":" << valvec[1] << " => index = " << rval << std::endl;
   return rval;
}

template<class T>
bool Tabulator<T>::setParameters( const std::vector<size_t> & indvec ) {
   if (indvec.size()!=m_tabMin.size()) return false; // FAIL!
   for (size_t i=0; i<m_tabMin.size(); i++) {
      if (indvec[i]<m_tabNsteps[i]) {
         m_parameters[i] = m_tabMin[i] + static_cast<double>(indvec[i])*m_tabStep[i];
      } else {
         std::cout << "ERROR: should not be here! index>=N(steps) of par " << i << std::endl;
      }
   }
   return true;
}

template<class T>
void Tabulator<T>::setParameters( const std::vector<double> & valvec ) {
   m_parameters = valvec;
   for (size_t i=0; i<valvec.size(); i++) {
      m_parChanged[i] = true;
   }
}

template<class T>
void Tabulator<T>::setParameters( const std::vector<size_t> & indvec, const std::vector<size_t> & indvecLast ) {
   if (!setParameters(indvec)) return;
   if (indvecLast.size()==indvec.size()) {
      for (size_t i=0; i<indvec.size(); i++) {
         m_parChanged[i] = (indvec[i]!=indvecLast[i]);
      }
   } else {
      for (size_t i=0; i<indvec.size(); i++) {
         m_parChanged[i] = true;
      }
   }
}

template<class T>
double Tabulator<T>::calcValue() const {
   std::cout << "Unspecified type! -> Define calcValue()" << std::endl;
   return 0;
}

template<class T>
double Tabulator<T>::getValue( const std::vector<double> & parvec ) {
   //   std::cout << "Calling getValue() : " << parvec[0] << " ; " << parvec[1] << std::endl;
   int ind = calcTabIndex( parvec );
   if (ind<0) {
      //      std::cout << "ind<0!" << std::endl;
      setParameters(parvec);
      return this->calcValue();
   }
   return this->interpolate( ind );
}

template<class T>
double Tabulator<T>::interpolate( size_t ind ) const {
  std::cout << "DEF INT!" << std::endl;
  return m_tabValues[ind]; // no interpolation
}

#endif

#endif
